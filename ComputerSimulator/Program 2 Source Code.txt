//Program 2
//6句话对每个单词编码后从内存512位开始存储 地址：“001000000000”
//存储将有fileReader自动进行

//DATA:
//单词循环计数初始化为512，存储在内存地址12
	000000001100, 0000001000000000
//Index寄存器值：
//X1: 64 		存放在地址13
	000000001101, 0000000001000000
//X2: 96		存放在地址14
	000000001110，0000000001100000
//句子数初始化为1，存放在内存15
	000000001111, 0000000000000001
//单词数初始化为1，存放在内存16
	000000010000, 0000000000000001

//Instructions:
//加载Index寄存器的值
//ADDRESS[64]	LDX x1,[0],01101							直接寻址，加载内存13的值到X1
//ADDRESS[65]	LDX x2,[0],01110							直接寻址，加载内存14的值到X2
//指令从内存地址64开始存储 地址：“000001000000”
//用户输入单词将存储在第11位 地址：“000000001011”
//ADDRESS[66]	IN r0, 0									从device0 读取内容存储到R0
//ADDRESS[67]	STR r0,x0,[0],01011 						STR直接寻址，将r0内容存储到内存地址000000001011处
//对每一个单词进行对比。循环

//1010:
//将第x个单词放入R1
//换行符为1010，结束符1011
//ADDRESS[68]	LDR r1,x0,[1],01100							间接寻址，将地址12的值对应的内存位置的值放入R1
//判断是否为换行符
//ADDRESS[69]	SIR r1,01010								直接用R1减去01010.如果为0则为换行符
//如果不是换行符，跳转到指令“1011”，否则进行换行符处理
//ADDRESS[70]	JNE r1,x1,[0], 10010						跳转到 64+18 = 82
//换行符处理：句子数+1，单词数更改为1
//句子数+1
//ADDRESS[71]	LDR r1,x0,[0],01111							加载Address[15]到R1
//ADDRESS[72]	AIR r1,00001								R1+1
//ADDRESS[73]	STR r1,x0,[0],01111							存储R1到Address[15]
//单词数改为1
//ADDRESS[74]	STR r1,x0,[0],10000							存储R1到Address[16]
//ADDRESS[75]	SMR r1,x0,[0],10000							清空R1(R1=0)
//ADDRESS[76]	AIR r1,00001								R1+1(0+1)
//ADDRESS[77]	STR r1,x0,[0],10000							存储R1到Address[16].此时内存地址16的值为1
//单词查找数(Address[12])加一
//ADDRESS[78]	LDR r1,x0,[0],01100							加载Address[12]到R1
//ADDRESS[79]	AIR r1,00001								R1+1
//ADDRESS[80]	STR r1,x0,[0],01100							存储R1到Address[12]
//跳转到指令“1010”
//ADDRESS[81]	JMA x1,[0],00100 							跳转到 64+4=68

//1011:
//判断是否为结束符
//ADDRESS[82]	LDR r1,x0,[1],01100							间接寻址，将地址12的值对应的内存位置的值放入R1
//ADDRESS[83]	SIR r1,01011								直接用R1减去01011.如果为0则为结束符
//如果结果不为0则跳转到指令“COMP”，否则进行结束符处理操作
//ADDRESS[84]	JNE r1,x1,[0],10111							跳转到64+23=87
//结束符处理操作：
//ADDRESS[85]	STR r1,x0,[0],01111							将R1的值存储到Address[15],此时R1值为0
//跳转到指令“OUTPUT”（输出结果）
//ADDRESS[86]	JMA x2,[0],00001							跳转到96+1=97

//COMP:
//将用户单词放进R0.
//ADDRESS[87]	LDR r0,x0,[0],01011							直接寻址，将地址11的值（用户单词）存入R0
//将R0(用户单词)与内存512+x（第x个单词）相减，比较两者是否相同。
//ADDRESS[88]	SMR r0,x0,[1],01100							间接寻址，将地址12的值对应的内存位置的值与R0相减
//如果是同一单词，则相减的值应为0，如果为0，则跳转到指令“OUTPUT”。
//ADDRESS[89]	JZ r0,x2,[0],00001							跳转到96+1=97
//如果不为0，则表示单词不同
//单词数（Address[16]）加一
//ADDRESS[90]	LDR r1,x0,[0],10000							加载Address[16]到R1
//ADDRESS[91]	AIR r1,00001								R1+1
//ADDRESS[92]	STR r1,x0,[0],10000							存储R1到Address[16]
//单词查找数（Address[12]）加一	
//ADDRESS[93]	LDR r1,x0,[0],01100							加载Address[12]到R1
//ADDRESS[94]	AIR r1,00001								R1+1
//ADDRESS[95]	STR r1,x0,[0],01100							存储R1到Address[12]
//跳转到指令“1010”：
//ADDRESS[96]	JMA x1,[0],00100							跳转到 64+4=68

//OUTPUT:
//将句子数输出
//ADDRESS[97]	LDR r1,x0,[0],01111							直接寻址，将地址15的值（句子数）存入R1
//ADDRESS[98]	OUT r1,device1								输出R1的值到Device 1
//将单词数输出
//ADDRESS[99]	LDR r1,x0,[0],10000							直接寻址，将地址16的值（单词数）存入R1
//ADDRESS[100]	OUT r1,device1								输出R1的值到Device 1
